#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <liburing.h>
#include <time.h>
#include <errno.h>

static inline long long timespec_to_ns(const struct timespec *t) {
    return (long long)t->tv_sec * 1000000000LL + t->tv_nsec;
}

int main(int argc, char **argv) {
    char *fileName = "io_uring.bin";

    size_t write_size = 4096;   // block size (bytes)
    size_t total_mb = 64;       // total size (MB)
    unsigned queue_depth = 16;  // default queue depth

    if (argc >= 2) fileName = argv[1];
    if (argc >= 3) write_size = (size_t)atoi(argv[2]);
    if (argc >= 4) total_mb = (size_t)atoi(argv[3]);
    if (argc >= 5) queue_depth = (unsigned)atoi(argv[4]);

    size_t iterations = (total_mb * 1024 * 1024) / write_size;
    if (iterations == 0) {
        fprintf(stderr, "Bad args: too few iterations\n");
        return 1;
    }

    int fd = open(fileName, O_CREAT | O_WRONLY | O_TRUNC | O_DIRECT, 0644);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    void *buffer;
    if (posix_memalign(&buffer, 4096, write_size)) {
        perror("posix_memalign");
        return 1;
    }

    for (size_t i = 0; i < write_size; i++) {
        ((unsigned char *)buffer)[i] = (unsigned char)(i & 0xFF);
    }

    struct io_uring ring;
    if (io_uring_queue_init(queue_depth, &ring, 0) < 0) {
        perror("io_uring_queue_init");
        return 1;
    }

    printf("io_uring demo:: total=%zu MB, block=%zu bytes, ops=%zu, qd=%u\n",
           total_mb, write_size, iterations, queue_depth);

    struct timespec tstart, tend;
    clock_gettime(CLOCK_MONOTONIC, &tstart);

    long long min_ns = (1LL << 62), max_ns = 0, sum_ns = 0;
    unsigned inflight = 0;

    for (size_t i = 0; i < iterations; i++) {
        struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
        if (!sqe) {
            fprintf(stderr, "uring get sqe failed\n");
            return 1;
        }

        off_t offset = i * (off_t)write_size;
        io_uring_prep_write(sqe, fd, buffer, write_size, offset);
        io_uring_submit(&ring);
        inflight++;

        if (inflight >= queue_depth) {
            struct io_uring_cqe *cqe;
            io_uring_wait_cqe(&ring, &cqe);
            if (cqe->res < 0) {
                fprintf(stderr, "write error: %s\n", strerror(-cqe->res));
                return 1;
            }
            if (cqe->res != (int)write_size) {
                fprintf(stderr, "short write: %d\n", cqe->res);
                return 1;
            }
            io_uring_cqe_seen(&ring, cqe);
            inflight--;
        }
    }

    // drain remaining completions
    while (inflight > 0) {
        struct io_uring_cqe *cqe;
        io_uring_wait_cqe(&ring, &cqe);
        if (cqe->res < 0) {
            fprintf(stderr, "write error: %s\n", strerror(-cqe->res));
            return 1;
        }
        io_uring_cqe_seen(&ring, cqe);
        inflight--;
    }

    clock_gettime(CLOCK_MONOTONIC, &tend);

    long long elapsed_ns = timespec_to_ns(&tend) - timespec_to_ns(&tstart);
    double elapsed_s = (double)elapsed_ns / 1e9;
    double throughput = (double)(iterations * write_size) / (1024.0 * 1024.0) / elapsed_s;

    printf("Total time: %.3f s, Throughput: %.2f MB/s\n",
           elapsed_s, throughput);

    io_uring_queue_exit(&ring);
    close(fd);
    free(buffer);
    return 0;
}
